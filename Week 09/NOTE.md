### 浏览器工作原理

#### parser 模块

1. **HTML 解析**

   - 接受 HTML 文本为参数，返回 Dom 树
   - **用 FSM 实现 HTML 分析**
     - 在 [HTML 标准](https://html.spec.whatwg.org/multipage/)中，已经规定了 HTML 的状态
     - toy-browser 只挑选了一部分状态，完成一个最简版本
   - **解析标签**（开始标签、结束标签、自封闭标签）

     - 在状态机中，除了状态迁移，还要加入业务逻辑
     - 创建 token、把字符加入 token、emit token
     - 在标签结束状态提交 token

   - **用 token 解析 Dom 树**
     - 基本技巧：**使用栈**。
     - 遇到**开始标签**时，创建元素并入栈；遇到**结束标签**时，出栈。
     - **自封闭标签**可视为入栈后立即出栈。
     - 任意元素的**父元素**是它入栈前的**栈顶**。
   - **将文本节点加入到 DOM 树**
     - 处理方式与自封闭标签类似：并不是真正的入栈。
     - 多个文本标签进行合并

2. **CSS 计算**
   - **收集 CSS 规则**
     - 遇到 style 标签，把 css 规则保存起来。
     - 调用 CSS parser 分析 CSS 规则。
     - 这里我们要研究此库分析 CSS 规则的格式。
   - **添加调用**
     - 当我们创建一个元素时，立即计算 CSS。
     - 理论上，当我们遇到一个元素时，CSS 规则已经收集完。
     - 在真实的浏览器中，遇到 body 里的\<style>，需要重新计算 CSS，我们忽略。
   - **获取父元素序列**
     - 必须知道该元素所有的父元素，才能知道是否与规则匹配
     - 从上一步骤的 stack 中，可以获取所有的父元素
     - 因为我们最先匹配的是当前元素，所以父元素的获取与匹配是**从内往外**的
   - **选择器与父元素的匹配**
     - 选择器也从内向外排序
     - 复杂选择器拆成针对单个元素的选择器，通过循环匹配父元素队列
   - **选择器与父元素匹配的 match 函数**
     - 根据选择器的类型和元素属性，计算是否匹配
     - 仅仅实现了三种基础选择器
   - **生成 computedStyle**
     - 一旦选择匹配，就应用选择器到元素上，生成 computedStyle
   - **specification(优先级)的计算逻辑**
     - CSS 规则根据 specificity 和后来者优先规则覆盖。
     - spcificity 是一个四元组，越左边权重越高。
     - 一个 CSS 规则的 specificity 根据包含的简单选择器相加而成。

### 其他

- slice(): 不传参数时，默认复制一次原数组
